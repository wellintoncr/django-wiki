{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Django Wiki","text":"<p>A ideia desta wiki \u00e9 apresentar solu\u00e7\u00f5es ou alternativas para problemas encontrados durante o desenvolvimento de aplica\u00e7\u00f5es Django.</p> <p>Isso n\u00e3o \u00e9 um substituto \u00e0 documenta\u00e7\u00e3o do framework de nenhuma forma.</p>"},{"location":"formatter/","title":"Formatadores","text":"<p>Formatadores \u00fateis</p>"},{"location":"formatter/#dinheiro-ou-similares","title":"Dinheiro (ou similares)","text":"<p>No template, coloque: <pre><code>variavel|floatformat:\"2g\"\n</code></pre> A formata\u00e7\u00e3o vai considerar a localiza\u00e7\u00e3o. Supondo que <code>variavel</code> seja 10.33333333, ent\u00e3o, se o locale for portugu\u00eas, o resultado ficar\u00e1 como <code>10,33</code>.</p> <p>Outros exemplos:</p> Valor Sa\u00edda <code>10.366666</code> <code>10,37</code> <code>1234.366666</code> <code>1.124,37</code> <code>10.0</code> <code>10,00</code> <p>O argumento <code>2</code> indica a quantidade de casas decimais (sempre com duas casas decimais, no caso). O <code>g</code> indica que haver\u00e1 agrupamento de milhar de acordo com o locale (em ingl\u00eas americano, por exemplo, o separador \u00e9 <code>,</code>).</p> <p>A documenta\u00e7\u00e3o completa pode ser acessada aqui.</p>"},{"location":"formatter/#forma-humanizada","title":"Forma humanizada","text":"<p>\u00c0s vezes pode ser necess\u00e1rio aplicar uma forma humanizada a algum valor. Para tal, o seguinte setup \u00e9 necess\u00e1rio:</p> <p>Primeiro, verifique se, em <code>settings.py</code>, o app <code>humanize</code> est\u00e1 incluso: <pre><code>INSTALLED_APPS = [\n    ...,\n    \"django.contrib.humanize\",\n]\n</code></pre> No template que ocorrer\u00e1 a convers\u00e3o, carregue o <code>humanize</code>: <pre><code>{% load humanize %}\n(restante do HTML)\n</code></pre> Todas as formas humanizadas abaixo necessitam deste setup.</p> <p>Documenta\u00e7\u00e3o</p>"},{"location":"formatter/#forma-humanizada-de-numeros-grandes-milhao-trilhao-etc","title":"Forma humanizada de n\u00fameros grandes (milh\u00e3o, trilh\u00e3o, etc)","text":"<p>Setup</p> <p>Na vari\u00e1vel a ser transformada, aplique um filtro:</p> <pre><code>variavel|intword\n</code></pre> <p>Alguns exemplos considerando o locale como portugu\u00eas brasileiro:</p> Valor Sa\u00edda <code>1_000</code> <code>1000</code> <code>1_000_000</code> <code>1,0 milh\u00e3o</code> <code>1_200_000</code> <code>1,2 milh\u00f5es</code>"},{"location":"formatter/#forma-humanizada-de-datas-ontem-hoje-e-amanha","title":"Forma humanizada de datas (ontem, hoje e amanh\u00e3)","text":"<p>Setup</p> <p>Na vari\u00e1vel a ser transformada, aplique um filtro:</p> <pre><code>variavel|naturalday\n</code></pre> <p>Alguns exemplos considerando o locale como portugu\u00eas brasileiro e que hoje \u00e9 02/01/2000:</p> Valor Sa\u00edda <code>date(2000, 1, 2)</code> <code>hoje</code> <code>date(2000, 1, 1)</code> <code>ontem</code> <code>date(2000, 1, 3)</code> <code>amanh\u00e3</code> <code>date(2000, 1, 4)</code> <code>04 de Janeiro de 2000</code>"},{"location":"forms/","title":"Formul\u00e1rios","text":"<p>Sem d\u00favidas, os formul\u00e1rios do Django facilitam a entrega de funcionalidades com pouco esfor\u00e7o.</p>"},{"location":"forms/#inputs-de-data","title":"Inputs de data","text":"<p>Existem, basicamente, duas formas de criar inputs de data e a escolha depende, essencialmente, de quem ter\u00e1 o controle das funcionalidades.</p> <ol> <li> <p>A primeira op\u00e7\u00e3o \u00e9 quando o controle de data deve ocorrer pelo navegador:</p> <p><pre><code>date_field = forms.DateField(\n    widget=forms.DateInput(\n        attrs={\n            \"type\": \"date\"\n        }\n    )\n)\n</code></pre> Neste cen\u00e1rio, Django tem pouco controle do que ocorre ali porque <code>DateInput</code> ser\u00e1 um <code>&lt;input type=\"date\"&gt;</code> e o navegador aplicar\u00e1 as regras dele. No Firefox, por exemplo, isso ser\u00e1 renderizado com um bot\u00e3o que permitir\u00e1 o usu\u00e1rio selecionar uma data sem precisar digitar todos os campos.  O navegador decide como exibir o input e como a sele\u00e7\u00e3o de data ocorrer\u00e1 (Firefox no desktop)  O locale do input tamb\u00e9m ficar\u00e1 a crit\u00e9rio do navegador, ent\u00e3o se ele foi configurado para portugu\u00eas brasileiro, provavelmente o padr\u00e3o ser\u00e1 <code>DD/MM/AAAA</code>, mas, se for ingl\u00eas americano, o padr\u00e3o ser\u00e1 <code>MM/DD/AAAA</code>.</p> <p>Observa\u00e7\u00e3o: como o navegador est\u00e1 ciente que o <code>input</code> \u00e9 uma data, ele garante que o que for digitado ser\u00e1 v\u00e1lido no locale do usu\u00e1rio, ou seja, n\u00e3o ser\u00e1 permitido digitar, por exemplo, <code>50/02/2000</code>. Al\u00e9m disso, se o usu\u00e1rio estiver usando um navegador no celular, o seletor nativo ajuda a pessoa a selecionar datas com mais facilidade do que digitar no teclado.  Como um input de data se comporta (Firefox no Android) </p> </li> <li> <p>A segunda op\u00e7\u00e3o \u00e9 colocar o controle do input para o Django:</p> <p><pre><code>date_field = forms.DateField(\n    input_formats=[\"%d/%m/%Y\"],\n    widget=forms.DateInput(),\n)\n</code></pre> Neste cen\u00e1rio, Django tem maior controle do input. No c\u00f3digo acima, <code>input_formats</code> recebe uma lista de poss\u00edveis formas de se inserir a data.</p> <p>Imagine um cen\u00e1rio em que, por algum motivo, se quer exibir o input sempre no padr\u00e3o <code>DD/MM/AAAA</code> independente do locale do navegador do usu\u00e1rio, ent\u00e3o a segunda op\u00e7\u00e3o permitir\u00e1 adicionar essa funcionalidade. O formato poderia ser de outras formas, por exemplo: <code>%m/%y</code> para aceitar apenas m\u00eas e ano (com dois d\u00edgitos).</p> <p> O navegador exibir\u00e1 apenas como um input do tipo <code>text</code>  A desvantagem \u00e9 que, como o navegador n\u00e3o sabe que aquilo \u00e9 um <code>date</code>, ele n\u00e3o consegue fornecer uma ferramenta de sele\u00e7\u00e3o de data. Al\u00e9m disso, um <code>placeholder</code> e possivelmente m\u00e1scara seriam \u00fateis tamb\u00e9m para minimizar essa desvantagem.</p> <p>O exemplo abaixo minimiza esses efeitos: <pre><code>date_field = forms.DateField(\n    input_formats=[\"%m/%d/%Y\"],\n    widget=forms.DateInput(\n        attrs={\n            \"class\": \"form-control\",\n            \"x-mask\": \"99/99/9999\",\n            \"x-data\": \"\",\n            \"placeholder\": \"DD/MM/AAAA\",\n            \"type\": \"text\" # (1)\n        }\n    )\n)\n</code></pre></p> <ol> <li><code>type text</code> \u00e9 o valor padr\u00e3o, ent\u00e3o \u00e9 opcional informar. Se quiser o tipo <code>date</code>, ent\u00e3o \u00e9 obrigat\u00f3rio informar.</li> </ol> <p>Observa\u00e7\u00e3o: o exemplo acima n\u00e3o garante que o usu\u00e1rio digite uma data inv\u00e1lida, por exemplo <code>90/60/0001</code>, apenas aplicar\u00e1 uma m\u00e1scara que impede caracteres diferentes de n\u00fameros de serem digitados.</p> <p>Na valida\u00e7\u00e3o do Django, isso ser\u00e1 barrado, mas o usu\u00e1rio ter\u00e1 a liberdade de digitar o que quiser - isso n\u00e3o ocorre com a primeira op\u00e7\u00e3o porque o navegador sabe que n\u00e3o existe um m\u00eas <code>60</code>, por exemplo.</p> </li> </ol>"}]}